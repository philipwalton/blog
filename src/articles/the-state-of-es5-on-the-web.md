In 2017, I [wrote an article](/articles/deploying-es2015-code-in-production-today/) showing web developers how they could deploy ES6+ code (a.k.a. ES2015) to production, without needing to transpile it to ES5. This technique was liberating for website developers who wanted the freedom to write modern code without having to worry about transpiler or polyfill bloat.

Unfortunately, while many website developers were able to use this technique, most JavaScript library _authors_ could not.

Library authors face a lot more constraints than website developers, because they don't control how their code is deployed. Also, since many of the popular build tools [recommend](#dont-transpile-node-modules-recommendations) developers exclude their `node_modules` directory from transpilation, library authors were forced to be extremely conservative—usually transpiling all the way back to ES5 in order to avoid potentially breaking sites.

But that was seven years ago, and there's been a ton of advancement in the JavaScript tooling space since then. The browser landscape has also changed tremendously. Most notably IE 11, the last remaining ES5 browser, [stopped being supported](https://support.microsoft.com/en-us/windows/internet-explorer-downloads-d49e1f0d-571c-9a7b-d97e-be248806ca70) by Microsoft in 2022, which meant many businesses could finally stop supporting it as well.

_So what is the current state of ES5 on the web today? And what are the best practices for web developers when building code for production?_

This article looks at the data we have to answer these questions. It also offers some concrete recommendations (based on that data) for how both website developers and library authors should approach legacy browser support moving forward.

## Quick disclaimer

Before digging into the real-world data on ES5 usage, I want to clarify that there is nothing inherently wrong with either authoring or publishing ES5 code.

JavaScript engines have been optimizing for ES5 code for much longer than they have for modern code, so if you have old ES5 code that is still working, there's no reason to update it just to make it "modern".

However, if you're authoring code in ES6+ syntax and then using a build tool to transpile it to ES5, that generally results in a lot of polyfill and transpiler bloat that can significantly increase the size of your final bundles.

To illustrate this point, here's a particularly egregious example:

```js
console.log([1, 2, 3].at(-1));
```

If you transpile this code to ES5 by hand, it would probably look something like this:

```js
var arr = [1, 2, 3];
console.log(arr[arr.length - 1]);
```

However, if you transpile this single line of code with [Babel](https://babeljs.io) and [configure it to add polyfills](https://babeljs.io/docs/babel-preset-env#usebuiltins)—even if you limited it to just the needed polyfills based on usage in the source code—it includes [187 core-js dependencies](https://gist.github.com/philipwalton/f7087b287be1af14bda41bcf35b6c3cc) and goes from being 31 bytes to [44,157 bytes minified!](https://gist.githubusercontent.com/philipwalton/f7087b287be1af14bda41bcf35b6c3cc/raw/b5a8126a95eac6a998406cb2d8d3df5b391fc8b5/output.js)

The point of this example is not to shame Babel or core-js. Those tools need to be able to support all possible ES6+ code, which requires them to account for all sorts of edge cases (though this particular example doesn't have any).

Instead, the point is to emphasize that choosing to support legacy browsers does come with a cost, and that cost can be significant.

Unfortunately, the problem is actually worse than just code bloat. If you look at the data below on how popular websites today are _actually_ transpiling and deploying their code to production, **it turns out that most sites on the internet ship code that is transpiled to ES5, yet _still_ doesn't work in IE 11**—meaning the transpiler and polyfill bloat is being downloaded by 100% of their users, but benefiting none of them.

## The data

To understand the state of ES5 on the web, you have to look at three things, since all of these play a critical role in the final output of code that we, as web users, receive:

- The default configurations of popular bundlers and build tools
- The state of code found in popular JavaScript libraries
- The state of code deployed by website owners

### Default bundler and build tool configurations

Most bundlers and build tools are extremely configurable and offer almost unlimited control over the final output of code. However, in practice, most developers just use the defaults, so the defaults matter a great deal.

What are those defaults? Specifically, do the defaults result in code being transpiled to ES5?

To answer that question I took a look at the output generated by some of the most popular build tools, according to the most recent [State of JS survey](https://2023.stateofjs.com) (2023), ordered roughly by popularity:

<table>
  <tr>
    <th>Tool</th>
    <th style="width:10em">Defaults to ES5?</th>
    <th>Notes</th>
  </tr>
  <tr>
    <td><a href="https://browsersl.ist/">Browserlist</a></td>
    <td>No</td>
    <td>Not a build tool itself, but used by many build tools internally and is the most popular open source tool for configuring browser support targets. The <code><a href="https://browsersl.ist/#q=defaults">defaults</a></code> setting no longer includes any ES5 browsers. The last one was IE 11, which was <a href="https://github.com/browserslist/browserslist/pull/701">marked as dead</a> in version 4.21.</td>
  </tr>
  <tr>
    <td><a href="https://babeljs.io">Babel</a></td>
    <td>Yes</td>
    <td>Babel's documentation recommends setting a <code><a href="https://babeljs.io/docs/options#targets">targets</a></code> option (which uses Browserlist), but if none is specified it will <a href="https://babeljs.io/docs/options#no-targets">transpile all code to ES5</a>.</td>
  </tr>
  <tr>
    <td><a href="https://webpack.js.org">webpack</a></td>
    <td>No</td>
    <td>By default, webpack does not transpile any code. Most webpack users include <code><a href="https://webpack.js.org/loaders/babel-loader/">babel-loader</a></code>, and webpack's <a href="https://webpack.js.org/loaders/babel-loader/#usage">usage example</a> for that suggests setting <code>targets: "defaults"</code>.</td>
  </tr>
  <tr>
    <td><a href="https://www.typescriptlang.org/tsconfig/#target">TypeScript (tsc)</a></td>
    <td>Yes</td>
    <td>TypeScript's default <code><a href="https://www.typescriptlang.org/tsconfig/#target">target</a></code> option is ES5 <em>(Note: the docs currently claim it's ES3, <a href="https://github.com/microsoft/TypeScript/pull/57525#issuecomment-1965538089">but that is not true</a>).</em></td>
  </tr>
  <tr>
    <td><a href="https://nextjs.org/">Next.js</a></td>
    <td>No</td>
    <td>Next.js <a href="https://nextjs.org/docs/pages/building-your-application/configuring/babel">uses Babel to transpile</a> and by default sets a Browserlist config that targets <a href="https://nextjs.org/docs/architecture/supported-browsers">"modern browsers"</a> (i.e. browsers that support ES modules).</td>
  </tr>
  <tr>
    <td><a href="https://esbuild.github.io">esbuild</a></td>
    <td>No</td>
    <td>esbuild <a href="https://esbuild.github.io/api/#target:~:text=The%20default%20target%20is%20esnext%20which%20means%20that%20by%20default%2C%20esbuild%20will%20assume%20all%20of%20the%20latest%20JavaScript%20and%20CSS%20features%20are%20supported.">does not transpile</a> by default. You can set a custom target to enable transpiling, but ES5 is not supported as a transpile target.</td>
  </tr>
  <tr>
    <td><a href="https://vitejs.dev/">Vite</a></td>
    <td>No</td>
    <td>Vite uses esbuild and by default sets custom targets for <a href="https://vitejs.dev/guide/build.html#browser-compatibility">"modern browsers"</a> (i.e. browsers that support ES modules). Vite allows users to install a <a href="https://github.com/vitejs/vite/tree/main/packages/plugin-legacy">plugin</a> if they need to support legacy browsers.</td>
  </tr>
  <tr>
    <td><a href="https://rollupjs.org/">Rollup</a></td>
    <td>No</td>
    <td>Rollup does not transpile by default. Many Rollup users install <a href="https://www.npmjs.com/package/@rollup/plugin-babel">@rollup/plugin-babel</a>, in which case the Babel defaults are used.</td>
  </tr>
  <tr>
    <td><a href="https://parceljs.org">Parcel</a></td>
    <td>No</td>
    <td>Parcel <a href="https://parceljs.org/features/production/#differential-bundling">automatically applies differential serving</a> with customizable targets.</td>
  </tr>
  <tr>
    <td><a href="https://github.com/google/closure-compiler">Closure Compiler</a></td>
    <td>No</td>
    <td><a href="https://github.com/google/closure-compiler/wiki/Flags-and-Options#basic-usage">Defaults</a> to <code>ECMASCRIPT_NEXT</code>, which is the latest set of stable ES features.</td>
  </tr>
</table>

As this table shows, the vast majority of bundlers and build tools no longer transpile to ES5 by default. It's also notable that newer tools do not support ES5 at all, which shows that the trend is moving in that direction.

That said, Babel is still the most popular tool to transpile JavaScript, and as a result transpiling to ES5 is still quite common on the web (see [ES5 usage in the wild](?tab=t.0#heading=h.5ozt10xh7puo) below for more details).

### Popular JavaScript libraries

In addition to looking at the popular build tools, I also looked at some of the [most popular libraries in use today](https://2023.stateofjs.com/en-US/other-tools/#libraries) (again based on the [State of JS survey](https://2023.stateofjs.com/), in rough popularity order):

To test each of these libraries, I created a bundle entry point that only imported that specific library, using one of the code examples from the library's documentation. I then bundled the code using both Rollup and Webpack to test the output and see if it included any ES6+ syntax (specifically, any ES6+ syntax that [isn't supported in IE 11](https://caniuse.com/?search=es6#:~:text=Notable%20partial%20support%20in%20IE11%20includes%20(at%20least%20some)%20support%20for%20const%2C%20let%2C%20block%2Dlevel%20function%20declaration%2C%20typed%20arrays%2C%20Map%2C%20Set%20and%20WeakMap.)).

Here's what I found:

<table>
  <tr>
    <th>Library</th>
    <th>Contains ES6+ syntax?</th>
    <th>Notes</th>
  </tr>
  <tr>
    <td><a href="https://lodash.com/">Lodash</a></td>
    <td>No</td>
    <td>ES5 only</td>
  </tr>
  <tr>
    <td><a href="https://react.dev/">React</a></td>
    <td>No</td>
    <td>ES5 only</td>
  </tr>
  <tr>
    <td><a href="https://date-fns.org/">date-fns</a></td>
    <td>Yes</td>
    <td>arrow functions</td>
  </tr>
  <tr>
    <td><a href="https://threejs.org/">three.js</a></td>
    <td>Yes</td>
    <td>async/await, arrow functions, spread, destructuring</td>
  </tr>
  <tr>
    <td><a href="https://d3js.org/">d3</a></td>
    <td>Yes</td>
    <td>arrow functions, spread, destructuring</td>
  </tr>
  <tr>
    <td><a href="https://www.framer.com/motion/">Framer-motion</a></td>
    <td>Yes</td>
    <td>arrow functions, spread, destructuring</td>
  </tr>
  <tr>
    <td><a href="https://gsap.com/">greensock</a></td>
    <td>No</td>
    <td>ES5 only</td>
  </tr>
  <tr>
    <td><a href="https://day.js.org/">dayjs</a></td>
    <td>No</td>
    <td>ES5 only</td>
  </tr>
  <tr>
    <td><a href="https://github.com/colinhacks/zod">Zod</a></td>
    <td>Yes</td>
    <td>async/await, arrow functions, spread, destructuring</td>
  </tr>
  <tr>
    <td><a href="https://rxjs.dev/">RxJS</a></td>
    <td>Yes</td>
    <td>arrow functions</td>
  </tr>
  <tr>
    <td><a href="https://immerjs.github.io/immer/">immer</a></td>
    <td>Yes</td>
    <td>arrow functions, spread, destructuring</td>
  </tr>
  <tr>
    <td><a href="https://moment.github.io/luxon">luxon</a></td>
    <td>Yes</td>
    <td>async/await, arrow functions, spread, destructuring</td>
  </tr>
  <tr>
    <td><a href="https://tanstack.com/query/">react-query</a></td>
    <td>No</td>
    <td>ES5 only (bundles Babel helpers)</td>
  </tr>
</table>

As the results above show, many popular JavaScript libraries are now publishing ES6+ syntax.

This is notable because, as I mentioned earlier, most developers configure their bundlers and build tools to not transpile anything in the `node_modules` directory, which was the main reason library authors historically felt they needed to continue transpiling to ES5.

<a id="dont-transpile-node-modules-recommendations"></a>

For example, as of when this article was published (September 2024):

- Webpack's `babel-loader` documentation [recommends a configuration](https://webpack.js.org/loaders/babel-loader/) that excludes `node_modules`.
- Rollup's `plugin-babel` documentation [recommends](https://www.npmjs.com/package/@rollup/plugin-babel#external-dependencies) excluding `node_modules` and also recommends that [library authors not publish ES6 code](https://www.npmjs.com/package/@rollup/plugin-babel#external-dependencies:~:text=We%20encourage%20library%20authors%20not%20to%20distribute%20code%20that%20uses%20untranspiled%20ES6%20features).
- TypeScript's `tsc` tool [ignores `node_modules` by default](https://www.typescriptlang.org/tsconfig/#exclude).

This creates a problem for any website that is trying to support ES5. Unless they have a sophisticated understanding of what their build process is doing and how to properly configure it, they're likely bundling ES6+ code in with their ES5 code without realizing it.

So this raises the question, is this _actually_ causing a problem for real websites, or are most of them properly configuring their tools? The next section looks at data from [HTTP Archive](https://httparchive.org/) to answer that question.

{% Callout 'info' %}
**Note:** some of the libraries in the table above publish both ES5 and ES6+ versions, typically with the ES5 version set on the `package.main` field, and the ES6+ version set on either the `package.module` or `package.exports` fields. In these cases I only looked at whatever version of the script was getting pulled in by the bundler when using the default configuration (since that's what most people use) and bundlers today default to using `package.module` or `package.exports` over `package.main` (see: [[1]](https://webpack.js.org/guides/package-exports/), [[2]](https://www.npmjs.com/package/@rollup/plugin-node-resolve), [[3]](https://esbuild.github.io/api/#conditions)).
{% endCallout %}

### ES5 usage in the wild

The three main tools developers use to transpile ES6+ code to ES5 are:

- Babel
- TypeScript (tsc)
- Closure Compiler (a.k.a. JSCompiler internally at Google)

All three of these tools include some form of polyfills and what are known as ES5 "helper" functions to avoid duplication in the final output. The most common ES5 helper function libraries used by these tools are: [babel-helpers](https://babel.dev/docs/babel-helpers), [core-js](https://github.com/zloirock/core-js), [regenerator-runtime](https://github.com/facebook/regenerator), [tslib](https://github.com/Microsoft/tslib), and [$jscomp](https://github.com/google/closure-compiler/tree/master/src/com/google/javascript/jscomp/js/es6).

Many of the functions in these helper libraries are unique enough that it's possible to detect (even in minified code) which sites are using them by querying the HTTP Archive. Searching for the presence of these helper functions—rather than standard ES5 syntax (such as `var` or non-arrow `function`)—helps to differentiate old ES5 code written by hand (usually fairly optimized) from newer ES5 code generated by a transpiler (usually fairly bloated).

I did a [search](https://docs.google.com/spreadsheets/d/1WAJEf00fHP9ShJCjfSxJr3t7qQoILjgmGgeQsT5wdzQ/edit?gid=968981083#gid=968981083) on to see how common it was for popular websites (top 10,000, based on [CrUX popularity ranking](https://developer.chrome.com/docs/crux/methodology/metrics#popularity-metric)) to include these helpers in the script bundles they deploy to production. I also wanted to see how common it was for sites to serve untranspiled ES6+ syntax.

Here's what I found ([full results](https://docs.google.com/spreadsheets/d/1WAJEf00fHP9ShJCjfSxJr3t7qQoILjgmGgeQsT5wdzQ/edit?usp=sharing)):

- <mark>**89%**</mark> of sites serve at least 1 JavaScript file containing untranspiled ES6+ syntax.
- <mark>**79%**</mark> of sites serve at least 1 JavaScript file containing ES5 helper code.
- <mark>**68%**</mark> of sites serve at least 1 JavaScript file containing _both_ ES5 helper code as well as untranspiled ES6+ syntax in the same file.

This last finding kinda blew my mind.

To reiterate what I said earlier—because it warrants repeating—if a browser does not support ES6+ syntax (such as IE 11), then it will error when trying to load a script file that contains ES6+ syntax. And if the browser *does* support ES6+ syntax, then it doesn't need any of that ES5 helper code or any of the legacy polyfills. There is absolutely no reason to include both.

To double check that the results of this query were accurate, I manually tested 20 random sites on the list and confirmed that they do in fact include both the ES5 helper code as well as ES6+ syntax in some of the same script bundles, and that those script bundles do indeed fail when loaded in IE 11.

Keep in mind that these are not just random sites on the Internet; these are the 10,000 most popular websites in the world, which account for the vast majority of all web usage globally.

### What does all this mean?

For a site to serve users code that contains both ES5 helpers and untranspiled ES6+ syntax, there's really only two plausible explanations:

1. The site doesn't need to support ES5 browsers, but some of their dependencies transpile to ES5, so therefore ES5 code appears in their output.
2. The site _intended_ to support ES5 browsers, but they didn't realize that some of their dependencies publish untranspiled ES6+ syntax, and they didn't configure their bundler to transpile code in `node_modules`.

Regardless of the explanation, the fact that so many of the world's most popular websites are serving so much unnecessary code, is a strong indicator that the defaults our tools currently recommend are not working.

If there's any silver lining in this data, it's that it's pretty clear to me that dropping IE support is not going to have a noticeable impact on most businesses. If all of these major companies are apparently not impacted by these broken IE experiences, yours probably won't be either.

## Recommendations

### For library authors

The original rationale for why library authors should transpile to ES5 was that most sites needed to transpile to ES5 anyway. However, given that 89% of the top 10,000 websites currently ship some untranspiled ES6+ syntax, that rationale is no longer valid.

Given the data presented in this article, <mark>it definitely does not make sense for JavaScript library authors to be transpiling their code to ES5 anymore.</mark>

Practically speaking, library authors have no information about the browser support needs of the websites importing them, so it doesn't make sense for them to be making that decision for all consumers of their library. At the same time, library authors shouldn't assume that all consumers of their library will be able to run it through a sophisticated build process, so it's important that their published code uses fully standard JavaScript and works in the current set of widely used browsers.

So what targets should library authors choose? In my opinion the best solution for library authors is to use [Baseline](https://web.dev/baseline)—specifically to only include [Baseline Widely Available](https://web.dev/baseline#:~:text=Widely%20available%3A%2030%20months%20has%20passed%20since%20the%20newly%20interoperable%20date.%20The%20feature%20can%20be%20used%20by%20most%20sites%20without%20worrying%20about%20support.) features in any published code.

If you're not familiar with Baseline, it's an effort by the [WebDX Community Group](https://www.w3.org/community/webdx/) within the W3C to help developers easily identify features that are stable and well supported by all major browsers and browser rendering engines across desktop and mobile. A feature is considered _Baseline Widely Available_ if it has been available in stable versions of all four major browsers for at least 30 months.

The main benefit of targeting something like _Baseline Widely Available_ is that it's a moving target, meaning it won't get stuck in the past, like what happened with targeting ES5 (and what is currently happening with the `esmodule` target used by Next.js, Vite, and Parcel).

Library authors can configure their build system to target _Baseline Widely Available_ features now with the following [Browserlist](https://browsersl.ist/) query (for any tool that supports Browserlist):

```js
targets: [
  'chrome >0 and last 2.5 years',
  'edge >0 and last 2.5 years',
  'safari >0 and last 2.5 years',
  'firefox >0 and last 2.5 years',
  'and_chr >0 and last 2.5 years',
  'and_ff >0 and last 2.5 years',
  'ios >0 and last 2.5 years',
]
```

{% Callout 'info' %}
**Note:** there's an open [feature request](https://github.com/browserslist/browserslist/issues/771) to add Baseline support to Browserlist, which would simplify the above query to just "baseline widely available".
{% endCallout %}

If a site needs to support more browsers than those covered by _Baseline Widely Available_, that's 100% fine. That site can always configure their build system to further transpile any libraries they're importing. The point is this is a decision best made by the website developers, not the library author.

### For website developers

The fact that so many popular websites ship both untranspiled ES6+ syntax and ES5 helpers in the same script bundle is a clear indication that <mark>the practice of excluding the `node_modules` directory from transpilation is not a good practice.</mark>

I've been arguing that this is not a good practice [since 2017](https://philipwalton.com/articles/deploying-es2015-code-in-production-today/#it%E2%80%99s-time-we-start-publishing-our-modules-as-es2015), but most developers I talked to didn't want to follow this advice because doing so would slow down their builds.

These days, though, build tools have gotten significantly faster. Also, sites can configure their builds to only process code in `node_modules` when building for production. In development the code should run just fine on any browser that the developer is using, especially if library authors take the advice I gave above and target _Baseline Widely Available_.

## Final thoughts

As I mentioned above, the point of this article is not to blame or shame websites or tool authors based on these findings. I also want to make sure it's clear that I'm definitely not suggesting that websites should still be supporting IE 11. If anything, these findings suggest that supporting IE 11 is not a necessity for most businesses, even large ones with a global customer base.

The main points I want readers to take from this article are:

<ul class="Checklist">
  <li>
    <strong>ES5 is no longer something that build tools or JavaScript libraries should target by default.</strong>
    <p>If tools still want to offer ES5 support, it should be something individual sites with specific support needs can opt into.</p>
  </li>
  <li>
    <strong>Build tools and libraries should not use a fixed browser support policy.</strong>
    <p>These policies can quickly become outdated, which leads to the scenario highlighted by the data in this article. Browser support decisions should be made by the site itself, not the tools it's using. A good browser support policy for tools and libraries is <a href="https://web.dev/baseline">Baseline Widely Available</a>.</p>
  </li>
  <li>
    <strong>Website developers who import third-party libraries should process those libraries as part of their build.</strong>
    <p>It's not safe to assume that all library authors have the same browser support needs as you. And as the data in this article shows, in many cases website developers many have wider browser support needs than the libraries they're importing (and thus need to further transpile them).</p>
  </li>
  <li>
    <strong>Cross-browser support is not something that you should solely rely on your build tool to handle for you.</strong>
    <p>If you need to support a specific set of browsers, then you need to be testing your site to ensure it works in those browsers.</p>
  </li>
</ul>

Hopefully this article has been useful to anyone who still worries about ES5 support, or to anyone trying to convince others not to worry!

If you're curious whether your site is serving script bundles that contain legacy ES5 helpers mixed in with untranspiled ES6+ code, you can search for your site in [the data](https://docs.google.com/spreadsheets/d/1WAJEf00fHP9ShJCjfSxJr3t7qQoILjgmGgeQsT5wdzQ/edit?usp=sharing) I shared above to see for yourself.

And if you discover that your site is doing this and you're able to fix it based on recommendations from this article, I'd love to [hear from you](/about/#contact)!
